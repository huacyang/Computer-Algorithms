## Minimum Spanning Tree

__Input.__
Undirected graph 0 = (V,E), and cost C<sub>e</sub> for each edge.

__Output.__
Min-cost (sum of the edge cost) tree T &le; E, expands all vertices.

* There are no cycles
* (V,T) is connected

__Assumption.__

* G is connected (else no spanning trees)
* Distinct edge costs

## Prim's Algorithm

Very Greedy-like.

* Initialize X = {s}, {s &isin; V is arbitrary}
* T = empty, {invariant, x = vertices spanned so far by T}
* Algorithm

```java
while x != V
  let e = (u,v)
    check past edge with u element of X, V not element of X
  add e to T
  add v to X
```

__Theorem.__
Prim always computes a MST

## Graph Theory Preliminaries

__Definition.__
A cut = partition of V into 2 non-empty sets

* For any given cut, there may be many edges that cross it
* For any given edge, there may be many cuts for which it crosses

__Empty Cut lemma.__
A graph is not connected, there exists a cut (A,B) with no crossing edges

__Double Crossing lemma.__
Suppose cycle C &le; E has edge e &isin; C that crosses a cut (A,B). Then, some other edge of C also crosses (A,B).

__Lonely Cut Corollary.__
If e is only edge crossing some cut (A,B), it is not in any cycle.

## Feasibility of Prim's Algorithm

__lemma.__
Prim outputs a spanning tree.

__Proof.__

1. Maintains invariant that T spans X (by Induction)
2. Can't stuck with X &#8800; T, else Empty Cut Lemma implies G is not connected
3. When e added to T, its the first edge of T to cross the cut (X, V-X). Its addition cannot create a cycle in T (by Lonely Cut Corollory)

## Cut Property

Proof using the exchange argument.

Suppose edge e is the cheapest edge of graph G crossing some cut (A,B), then e belongs to every MST.

__Claim.__ Cut Property implies the correctness of Prim's Algorithm.

__Proof.__ Prim outputs a spanning tree T*. Every edge e &isin; T* is explicitly justified by the Cut Property. Therefore, T* is the (unique) MST.
